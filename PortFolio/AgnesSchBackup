/**
 * Date Tool box
 */
    //Convert Time To Date Obj   //dObj
    //Convert Time To Millisecond  //mili  
    //Replace HF1   //cHF
    //Convert To range of dates //rdObj
    //return nonduplicate set  //cdup
    //get 1 date or 2 dates, ignore HF and hyphenate  //sd

let dtb = {   //date tool box
    dObj(d){return  new Date( d + "UTC+8")},
    mili(d){return this.dObj(d).getTime()},
    cHF(d){return d.replace(/([\(（]\s*HF[12]\s*[\)）])\s*/,'')},
    gd(dstr){return dstr.match(/(\d?\d\s+\w{3}\s+\d{4})/ig)},
    rdObj(dstr){
     if(dtb.gd(dstr).length ==1){
       return [dtb.dObj(dstr)];
     }else{ 
       return Array.from(
          {length: ((Math.abs(dtb.dObj(dtb.gd(dstr)[0] ).getTime()-dtb.dObj( dtb.gd(dstr)[1]).getTime()))/8.64e7+1)}, 
          drange, 
          {start: (dtb.gd(dstr).sort( (a,b) => dtb.dObj(a) - dtb.dObj(b) )[0])+'UTC+8',factor: 0,});}
                },
    cdup(ts){return Array.from(new Set(ts))},
    dmonth(utc8mili){ return new Date(utc8mili).toLocaleDateString('default',{month: 'short', timeZone:'Asia/Singapore'})} 
}


//Get Monthly SHeet data
  msdata = (sheetnamee) => ss.getSheetByName(sheetnamee).getDataRange().getValues();  //monthly sheet


//Get Timestamp col index
  msheader = (mssheet) => SpreadsheetApp.getActiveSpreadsheet().getSheetByName(mssheet).getRange("1:1").getValues()[0];  //monthly sheet header


//Get Pasted Row Number
      get_prRow = (fd_date, sheetnamee) => 
      msdata(sheetnamee).map(  x=> x[hIdxArr(tstmp,msheader(sheetnamee) )] ).map( (x,i) => [x].concat([i+1]) ).concat([[ (new Date(fd_date))]]).map(x =>  (typeof x[0] == 'object'&& x[0]!=='')? [x[0].getTime(),x[1]]:x   ).sort( (a,b) => a[0] - b[0]  ).reduce( (acc,cur,i) =>  
          {if(cur[1] == undefined ){
            prRow = acc[1]
              return cur
          }else{
          return cur
          }
          }
          ,[0,0]) 


function fd2obj(fd){   //transform array to obj, split dates to 3 group
let fdobj = headers.reduce( (acc, cur, i) => { acc[cur] = fd[i];return acc} ,{})
  for ( key in fdobj){ RegExp(dot).test(key)?(fdobj[key] = {
    Full: ( fdobj[key].split(/[,，]/)).filter( x => !(/HF[12]/.test(x)) ).filter(x => x !=='') ,
    HF1:  ( fdobj[key].split(/[,，]/)).filter( x => (/HF1/).test(x)  ).filter(x => x !==''),
    HF2:  ( fdobj[key].split(/[,，]/)).filter( x => (/HF2/).test(x) ).filter(x => x !=='')}):''
;}
  return fdobj;
 }


 function vdCheck(d){   //check if date is valid
    let dy = d.match(/\b(0?[1-9]|[12]\d|30|31)\b/g);
    let yea = d.match(/\d{4}/g);
    let test_date = new Date(d );
    return vdcheck =
       test_date.getFullYear() == yea &&
       test_date.getDate() == dy;
 } 

function drange(){   //date range fn
  return new Date (  new Date(this.start).setDate(new Date(this.start).getDate()+ (this.factor++)) )
}


 monthlist = (m,y) => {       //create dates within a month
      return Array.from(
        {length: new Date(y, m +1, 0).getDate()}, function(){ 
      return new Date (  new Date(this.start).setDate(new Date(this.start).getDate()+ (this.factor++)) )
      }
     , {start: (new Date(new Date (y,m,1).toDateString() +'UTC+8')) ,factor: 0} 
      );
     }



/**
 * Header index
 */
let hIdxS = (hname,headersData) =>  headersData.indexOf(hname)+1; //Header index for Spreadsheet usage
let hIdxArr = (hname,headersData) =>  headersData.indexOf(hname); //Header index for array usage


/**
 * Invalid Detection
 */

//Special remark detection
  let detSPR = (fdrow) => fd[hIdxArr(rmk,headers)] !== ''?(sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Special Remark"), ui.alert(`<<ERROR>>:\n\nSpecial Remark at row ${fdrow}`),fail):'';

  //Blank date detection
  let detblk = (fdrow) => headers.reduce( (acc,cur, ind) => RegExp(dot).test(cur)?acc.concat([fd[ind]]):acc,[]).filter(x => x !=='').length == 0?(ui.alert(`<<ERROR>>\n\n Blank Dates at row ${fdrow}`),sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Blank Dates"),fail):'';
//

//Invalid date detection
  let detInvD = (fdrow) => headers.map( (h,i) => RegExp(dot).test(h)? (fd[i] == ''?'':
    fd[i].match(/(\d?\d\s+\w{3}\s+\d{4})/ig)==null?(sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Invalid Date"),ui.alert(`Invalid date in data at row ${fdrow}`),fail):
    
    (  fd[i].match(/(\d?\d\s+\w{3}\s+\d{4})/ig).forEach(  d => 
      (vdCheck(d) == false)? (ui.alert(`<<ERROR>>\n\nInvalid Date Found at row ${fdrow}`),sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Invalid Date"),fail):''
                                                    ))

    ):''
  );
//


//Duplicate Submit
  let detDupSub = (fdrow) => sheet.getRange(2,1,fdrow-2,headers.length).getValues().filter(
    x => 
    x[hIdxArr(emel,headers)] == fd[hIdxArr(emel,headers)] && 
    x[hIdxArr(d1,headers)] == fd[hIdxArr(d1,headers)] && 
    x[hIdxArr(d2,headers)] == fd[hIdxArr(d2,headers)] 
  ).length > 0? (ui.alert(`<<ERROR>>\n\n Agent submitted duplicate data before!`),sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Duplicate Submit"),fail):'';
//


//Date crash Detection
  //flatten object into array
  //use set size to check if duplicate
let detCrash = (fdrow) => headers.map( (h,i) => 
{if(RegExp(dot).test(h)){
      var allALTYPE =   Object.entries(fd[h]).reduce( (acc, cur, ind) =>  
      acc.concat(...cur[1]),[]);
      allALTYPE.filter(x => x !== '').length == dtb.cdup(  allALTYPE  ).filter(x => x !== '').length?'':
    (ui.alert(`<<ERROR>>\n\nDate Crash at row ${fdrow}`),sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Date Crash"),fail)}});
//


//Subset Test- Flatten (flatDate and flatMonth)
  //Flatten Objs to 2 Arrays
    //call each Dot Obj
    //Create Flat obj in array -> 
        //Object Entries + reduce loop each ALtype and element and add Al type tag
        // [].concat([]) will return []
        // [].filter(String) return []
        // [].concat([1]) return [1], same for [1].concat([])
  //Either Empty Skip, 
    //else (smallest or 2nd have all index >0) empty smallest
let flatd1d2 = () => headers.map( (h,i) => 
    {if ( RegExp(dot).test(h) ){

    fd['flat'+h] =  Object.entries(fd[h]).reduce( (acc,cur,i) => 
          acc.concat(cur[1].map( x => cur[0] + '-' + x   ))
      ,[]).filter(x => x !== '');

    // fd['monthlySheet'+h] =  dtb.cdup(
    //       Object.entries(fd[h]).reduce( (acc,cur,i) => 
    //           acc.concat(cur[1].map( x => dtb.dmonth(x)   ))
    //           ,[]).filter(x => x !== '')
    //           );
                                };
    }
    );


//Subset Empty Test
  //loop each keys obj.entries(fd)
    //if name has "flat" and not empty and acc is empty
      //put acc
    //if name is flat and not empty and acc isn't empty
      //compare with acc
        // basically acc is 1st. cur is 2nd
            //if acc < cur, swap acc and cur
            //set variable swap as true if acc <cur
        // act upon cur indexOf every >=0
          //clear flat cur  and Object.entries(fd[replace flat to '']).map()
          //swap flat and fd if required


  let detSub = () => Object.entries(fd).reduce( (acc,cur,i) => {
  
  if( RegExp(flt).test(cur[0]) && cur[1].length >0 && acc.length == 0  ){
      return acc.concat(cur)
  
  }else if( RegExp(flt).test(cur[0]) && cur[1].length >0 && acc.length > 0 ){
      
      if( acc[1].length < cur[1].length ){
        var firstIsEmp = true;
          [acc,cur] = [cur,acc];}

    console.log(`Swap in subset test: ${firstIsEmp}`),

    cur[1].map( (x,ind) => acc[1].indexOf(x) ).every( j => j>=0 )? 
     ( fd[cur[0]] = [],
      
      Object.entries(fd[cur[0].replace(flt,'')]).map( (x,i) =>   
        fd[cur[0].replace(flt,'')][x[0]] = []) ,
      
      firstIsEmp? (
      (function (){ [fd[cur[0]], fd[acc[0]]] = [fd[acc[0]], fd[cur[0]]]})(),
      (function(){ [fd[cur[0].replace(flt,'')], fd[acc[0].replace(flt,'')  ]] = [fd[acc[0].replace(flt,'')  ], fd[cur[0].replace(flt,'')]]})()
        ):''

    )
     :'';

  return acc

  }else{
    return acc
  }

  }

  ,[]);


//Swap DoA if 1st is empty
    //{ [objt3['arr1'], objt3['arr2']] = [objt3['arr2'], objt3['arr1']]};


//Generate uuid
  guuid = (fd) => fd['uuid'] = `${ fd[tstmp].getTime() }${new Date().getTime()}` ;

//Generate color
  colorpencil = (fd) => fd['color'] =  colors[Math.floor(Math.random() * colors.length)];
  

// //Plotting
//   //get DoA from Map
//   // RegExp('\\b'+dot).test() 
//   return object month array
    //

Object.entries( fd ).map( (x,i) => 
    {
    if(RegExp('\\b'+dot).test(x[0]))        //keys of fd
      {

  var plotData =   Object.entries(fd[x[0]]).reduce(  (acc,cur,i) => //altype
    {
      cur[1].reduce( (acc2,cur2,ind) =>  //element in altype, cur[0] is key
          //if keys undefined, create new keys
          {    
            if(acc[dtb.dmonth(cur2)]  == undefined ){   
               acc[dtb.dmonth(cur2)] =  monthlist( new Date(cur2).getMonth() , new Date(cur2).getFullYear() );       //create list of dates
               acc[dtb.dmonth(cur2)] = acc[dtb.dmonth(cur2)].map( j => { j.getTime()  
                  .map( k =>  k == cur2?cur[0]:k)});   //convert time 2 keys
              return acc2                                                
            }else{            
          //else paste related keys
            acc[dtb.dmonth(cur2)] = acc[dtb.dmonth(cur2)].map( j =>  //list of date w/n a month
                {j.getTime()  
                  .map( k =>  k == cur2?cur[0]:k ); //convert time 2 keys if match
                  return acc2
                 })
                  }
          },[]);
         return acc
     }
     ,{});
    
    //if all empty
      // 1st DoA new RegExp("\\bDate of Application(?!\\s\\(Option 2\\))","ig").test(x[0])

    if( plotData.length == 0 ){
      console.log("Empty plotData detected");
    }else if( new RegExp("\\bDate of Application(?!\\s\\(Option 2\\))","ig").test(x[0]) ) {

      for (key in plotData){
        
        //Variables
            // msdata(key) //whole sheet
            // msheader(key)   //get header
            // plotData[key]  // plot array
        
        //Actions:
          // get_prRow(fd[tstmp],key); // generate row number for specific month sheet
          // prRow //particular row
          // ss.getSheetByName(key).insertRowAfter(prRow)
  
            //set backgrounds  
          //  ss.getSheetByName(key).getRange( prRow+1, (msheader(key).map(  (x,i) => typeof x  ).indexOf('object')+1) , 1 , plotData.length  ).setBackgrounds( [plotData[key].map( p => typeof p == 'object'?'#ffffff':fd[clr] )]  )
  
            //set values        
                //if more than 1 month, add comment
          // ss.getSheetByName(key).getRange( prRow+1, 1 , 1 , msheader(key).filter(fil => fil !== '').length  ).setValues( [[ (Object.keys(plotData).length > 1? 'Agent Applied > 1 month':''), fd[id],fd[tstmp],fd[nm],fd[extmel]   ].concat(plotData[key].map( p => typeof p == 'object' || p == full?'':p ))] );

              // return month name
          // fd['month'+x[0]] = Object.keys(plotData)

      }
    }else{
        // comment if more than 1 month
          //if no same uuid found, create new prRow

        //set notes
        //  ss.getSheetByName(key).getRange( prRow+1, (msheader(key).map(  (x,i) => typeof x  ).indexOf('object')+1) , 1 , plotData.length  ).setNotes( [plotData[key].map( p => typeof p == 'object'?'':p )]  )

          // return month name
        // fd['month'+x[0]] = Object.keys(plotData)


    }
    



        
        





}
     }



   );

  




/** 
 * Declare Variable
 */

let ss = SpreadsheetApp.getActiveSpreadsheet();
let ui = SpreadsheetApp.getUi();
let response_sheetName = "Form responses 8";

var sheet = ss.getSheetByName(response_sheetName);



//variable list
let tstmp = 'Timestamp';
let id = 'uuid';
let nm = 'Full Name';
let full = 'Full';
let rmk = 'Remarks (if neccessary otherwise ignore)';
let tg = 'Tag';
let dot = 'Date of Application';
let flt = 'flat';
let d1 = 'Date of Application';
let d2 = 'Date of Application (Option 2)';
let fdrow = 45;
let emel = 'Email address';
let extmel = 'Ext Email';
let color = 'clr';


// color array
    //white '#ffffff'
  let colors =  [ 
      '#ffff00',
      '#0000ff',
      '#00ff00',
      '#e69138',
      '#ff0000',
      '#9900ff',
      '#00ffff' ];



//Stop exe = fail


//Get Data
let headers = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(response_sheetName).getRange("1:1").getValues()[0];  //headers

msheader = (mssheet) => SpreadsheetApp.getActiveSpreadsheet().getSheetByName(mssheet).getRange("1:1").getValues()[0];  //monthly sheet header

var fd = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(response_sheetName).getRange(eval("`${fdrow}:${fdrow}`")).getValues()[0]; //form data




function sub() {

detSPR(fdrow);
detblk(fdrow);
detInvD(fdrow);
detDupSub(fdrow);
fd = fd2obj(fd);

  console.log(fd);




//split dates, clear duplicate w/in AL type, convert to time str
    //give some feedback if date is invalid
try {
    for (keys in fd){
      if(RegExp(dot).test(keys)){
        for (alType in fd[keys]){
          fd[keys][alType] = dtb.cdup(
            [].concat(...fd[keys][alType].map( x => dtb.rdObj(x)) ).map( x => x.getTime())
          ) } }
        };
} catch(error){
    ui.alert(`<<ERROR>>\n\n There migh be invalid date at row ${fdrow}`);
    sheet.getRange(fdrow,hIdxS(tg,headers)).setValue("Invalid Dates or Format");
    throw new Error("There might be invalid date or Format")
}



  console.log(fd);


detCrash(fdrow);
flatd1d2();
detSub();
guuid(fd);
colorpencil(fd);


  // console.log(fd.uuid);
  console.log(fd);

  //console.log(  dtb.dmonth(fd['Date of Application']['Full'][0])  ) //get month

   
}
























